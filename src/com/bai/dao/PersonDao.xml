<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace:映射文件的命名空间，规范是映射文件的全路径-->
<!--作用：是一个路径，用来查找 下面的id-->
<mapper namespace="com.bai.dao.PersonDao">
    <resultMap id="BaseResultMap" type="com.bai.bean.Person">
        <!--下面的 标签要映射到实体类-->
        <!--id 只有1个-->
        <!--column 是数据库中的 列名-->
        <!--property 是实体类中的属性 一般是驼峰-->
        <id column="id" property="id" />
        <result column="name" property="name"/>
        <result column="gender" property="gender"/>
        <result column="birthday" property="birthday"/>
        <result column="address" property="address"/>
        <result column="score" property="score"/>

    </resultMap>

    <!--sql片段-->
    <sql id="allColumn">
        id,name,gender,birthday,address
    </sql>

    <!--隐藏生日的sql 片段-->
    <sql id="birthdayColumn">
        id,name,gender,address
    </sql>

    <!--com.bai.dao.PersonDao+id就是全名-->
    <select id="selectAll" resultMap="BaseResultMap">
        select * from person
    </select>

    <!--sql 语句中携带参数，其实就是指的where语句 parameterType  paramaeter:参数的 type类型 (int,String,map,set)-->
    <!--select * from person where gender = 2-->
    <select id="selectPersonBySex" resultMap="BaseResultMap" parameterType="int">
        select <include refid="birthdayColumn"/> from person where gender = #{sex}
    </select>


    <!--查总条数：select count(*) from person; 14条 是一个 int 类型-->
    <!--和上面2个返回-->
    <select id="selectCount" resultType="long">
        select count(*) from person
    </select>


    <!--查询女生总条数有几个：select count(*) from person where sex=2 and score>100-->
    <!--当前端传来 多个参数的时候，你需要看这个几个参数，是否是同一个类中的属性(这个是单表)，如果是那么直接可以用这个类做参数，-->
    <!--如果 不是同一个类中的(这个是多表！！！)，那么 卡伊 手写一个 参数的实体类(DTO) ,或者 使用Map做参数-->
    <select id="selectCountByParam01" resultType="long" parameterType="com.bai.bean.Person">
          select count(*) from person where gender=#{gender} and score>#{score}
    </select>


    <!--查询性别是2，且生日小于2020-10-14 的人有哪些？-->
    <!--select * from person where gender=#{gender} and birthday<#{birthday}-->
    <select id="selectCountByParam02" resultMap="BaseResultMap" parameterType="map">
        <![CDATA[ select * from person where gender=#{gender} and birthday < #{birthday} ]]>
    </select>

    <!--子查询-->
    <!--查询 分值最高的人是谁？ -->
    <select id="selectPersonByZi" resultMap="BaseResultMap">
        select * from person where score=(select max(score) from person)
    </select>


    <!--分组查询-->
    <!--所有男生和女生的平均分值是多少？ select gender,avg(score) as avgScore from person group by gender-->
    <select id="selectAvgScore" resultType="com.bai.bean.dto.PersonDTO">
          select gender,avg(score) as avgScore from person group by gender
    </select>

    <!--男生和女生的平均分值 大于200的 是什么-->
    <!--select gender,avg(score) as avgScore from person group by gender having avg(score)>200-->
    <select id="selectAvgScoreParam" resultType="com.bai.bean.dto.PersonDTO" parameterType="int">
        select gender,avg(score) as avgScore from person group by gender having avg(score)>#{score}
    </select>

    <!--用map可以接受 任何的数据，常见于多表-->
    <select id="selectAvgScoreParam02" resultType="map" parameterType="int">
          select gender,avg(score) as avgScore from person group by gender having avg(score)>#{score}
    </select>


    <!--查询 姓 孙的 第一种方式:使用$去拼接，但是这样不好，因为是拼接的，sql编译的时候没有?,容易被黑客注入不安全-->
    <!--select * from person where name like '孙%'-->
    <select id="selectPersonByLike" resultMap="BaseResultMap" parameterType="string">
        select * from person where name like '${name}%'
    </select>
    <!--查询 姓 孙的 第二种方式:使用sql语句concat链接 是可以编译，可以使用这个-->
    <!--select * from person where name like '孙%'-->
    <select id="selectPersonByLike02" resultMap="BaseResultMap" parameterType="string">
        select * from person where name like concat ('%',#{name},'%')
    </select>

    <!--查询 姓 孙的 第三种方式:谢欣爱用的 是可以编译的，可以用这个-->
    <select id="selectPersonByLike03" resultMap="BaseResultMap" parameterType="string">
        select * from person where name like "%"#{name}"%"
    </select>

    <!--增加一条数据 insert into person (id,name,gender,birthday,address,score) values ( null, #{name}, ...)-->
    <!--场景：学生多   班级1，当我 张三 cid ，李四 cid,王五 cid 学生表 ，大数据 id 班级表-->
    <!--插入数之后，自动上报我们主键id 很重要！！！-->
    <!--selectKey 一般多表 级联插入的时候,需要获取刚刚插入的数据的主键id的时候,用到的-->
    <!--keyProperty 是指 主键的id-->
    <!--order值的是 自增的主键是 数据插入后诞生的还是插入前诞生的，mysql after， oracle 前-->
    <!--resultType 主键id的数据类型，一般int ，分布式是string 雪花算法-->
    <!--select LAST_INSERT_ID() 查询最后插入的主键id-->
    <insert id="insertPerson" parameterType="com.bai.bean.Person">
        <selectKey keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
        insert into person (id,name,gender,birthday,address,score)
        values ( null, #{name}, #{gender},#{birthday},#{address},#{score})
    </insert>

    <!--删除一条数据-->
    <delete id="deletePersonById" parameterType="int">
        delete from person where id=#{id}
    </delete>

    <!--动态sql之 动态查询 通俗讲： 就是 select+if 判断-->
    <!--动态sql标签有9个, where 1 ，删除 第一个and 2.代替了 原始sql中的where，where常和id搭配-->
    <!--where里需要把方法里的参数（map，实体类）的属性 写全-->
    <!--if的注意事项 test="gender 是指的 实体类中的属性 驼峰的-->
    <select id="dongTaiSelect" resultMap="BaseResultMap" parameterType="com.bai.bean.Person">
        select * from person p
          <where>
              <if test="id !=null and id !=''">
                  p.id=#{id}
              </if>

              <if test="name !=null and name !=''">
                 and  p.name=#{name}
              </if>

              <if test="gender !=null and gender !=''">
                  and  p.gender=#{gender}
              </if>

              <if test="birthday !=null and birthday !=''">
                  and  p.birthday=#{birthday}
              </if>

              <if test="address !=null and address !=''">
                  and  p.address=#{address}
              </if>

              <if test="score !=null and score !=''">
                  and  p.score>#{score}
              </if>
          </where>
    </select>

    <!--动态的修改  update person set xx=xx where id=? -->
    <!--set 标签-->
    <update id="dongTaiUpdate" parameterType="com.bai.bean.Person">
        update person p
          <set>
              <if test="name !=null and name !=''">
                    p.name=#{name} ,
              </if>

              <if test="gender !=null and gender !=''">
                    p.gender=#{gender} ,
              </if>

              <if test="birthday !=null">
                    p.birthday=#{birthday} ,
              </if>

              <if test="address !=null and address !=''">
                    p.address=#{address} ,
              </if>

              <if test="score !=null and score !=''">
                    p.score>#{score}
              </if>
          </set>
          where p.id=#{id}
    </update>
    
    <!--批量删除 动态sql之 foreach-->
    <!--delete from person where id in (1,2,3,4)-->
    <!--(1,2,3,4) 把他当作一个集合看待 ids-->
    <delete id="piLiangDel" parameterType="map">
        delete from person where id in
        <foreach collection="ids" open="(" item="id" separator="," close=")" index="index">
            #{id}
        </foreach>
    </delete>
</mapper>